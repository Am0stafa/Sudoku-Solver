{"ast":null,"code":"export function checkGrid(grid) {\n  for (let i = 0; i < 9; i++) {\n    let rowSet = new Set();\n    let colSet = new Set();\n    let boxSet = new Set();\n    for (let j = 0; j < 9; j++) {\n      let r = grid[i][j]; //current row cell checked\n      let c = grid[j][i]; //current col cell checked\n      let b = grid[3 * Math.floor(i / 3) + Math.floor(j / 3)][3 * (i % 3) + j % 3]; //current box cell checked\n\n      if (r === 0) {\n        return false;\n      } else if (rowSet.has(r)) {\n        return false;\n      } else {\n        rowSet.add(r);\n      }\n      if (c === 0) {\n        return false;\n      } else if (colSet.has(c)) {\n        return false;\n      } else {\n        colSet.add(c);\n      }\n      if (b === 0) {\n        return false;\n      } else if (boxSet.has(b)) {\n        return false;\n      } else {\n        boxSet.add(b);\n      }\n    }\n  }\n  return true;\n}\nexport async function solveGrid(grid, setGrid) {\n  const newGrid = [...grid];\n  const emptySquare = findEmpty(grid);\n  if (emptySquare[0] === -1 && emptySquare[1] === -1) {\n    return true; //Grid is full\n  }\n  for (let i = 1; i < 10; i++) {\n    if (isValid(grid, emptySquare, i)) {\n      //see if num can fit\n      grid[emptySquare[0]][emptySquare[1]] = i;\n      setGrid(newGrid);\n      await sleep(window.solveSpeed);\n      if (await solveGrid(grid, setGrid)) {\n        //recursivly check new grid, if new grid is full then returns true SOlution Found\n        return true;\n      } else {\n        //try again with new number\n        grid[emptySquare[0]][emptySquare[1]] = 0;\n        setGrid(newGrid);\n        await sleep(window.solveSpeed);\n      }\n    }\n  }\n  return false;\n}\nfunction findEmpty(grid) {\n  for (let row = 0; row < 9; row++) {\n    for (let col = 0; col < 9; col++) {\n      if (grid[row][col] === 0) {\n        return [row, col];\n      }\n    }\n  }\n  return [-1, -1];\n}\nfunction isValid(grid, square, num) {\n  for (let i = 0; i < 9; i++) {\n    if (grid[square[0]][i] === num && i !== square[1]) {\n      return false;\n    }\n  }\n  for (let i = 0; i < 9; i++) {\n    if (grid[i][square[1]] === num && i !== square[0]) {\n      return false;\n    }\n  }\n  const boxRow = Math.floor(square[0] / 3);\n  const boxColumn = Math.floor(square[1] / 3);\n  for (let i = boxRow * 3; i < boxRow * 3 + 3; i++) {\n    for (let j = boxColumn * 3; j < boxColumn * 3 + 3; j++) {\n      if (grid[i][j] === num && i !== square[0] && j !== square[1]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction sleep(duration) {\n  if (duration === 0) {\n    return;\n  }\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve();\n    }, duration);\n  });\n}","map":{"version":3,"names":["checkGrid","grid","i","rowSet","Set","colSet","boxSet","j","r","c","b","Math","floor","has","add","solveGrid","setGrid","newGrid","emptySquare","findEmpty","isValid","sleep","window","solveSpeed","row","col","square","num","boxRow","boxColumn","duration","Promise","resolve","setTimeout"],"sources":["/Users/abdomostafa/Sudoku-Solver/src/util.js"],"sourcesContent":["export function checkGrid(grid) {\n  for (let i = 0; i < 9; i++) {\n    let rowSet = new Set();\n    let colSet = new Set();\n    let boxSet = new Set();\n\n    for (let j = 0; j < 9; j++) {\n      let r = grid[i][j]; //current row cell checked\n      let c = grid[j][i]; //current col cell checked\n      let b =\n        grid[3 * Math.floor(i / 3) + Math.floor(j / 3)][3 * (i % 3) + (j % 3)]; //current box cell checked\n\n      if (r === 0) {\n        return false;\n      } else if (rowSet.has(r)) {\n        return false;\n      } else {\n        rowSet.add(r);\n      }\n\n      if (c === 0) {\n        return false;\n      } else if (colSet.has(c)) {\n        return false;\n      } else {\n        colSet.add(c);\n      }\n\n      if (b === 0) {\n        return false;\n      } else if (boxSet.has(b)) {\n        return false;\n      } else {\n        boxSet.add(b);\n      }\n    }\n  }\n  return true;\n}\n\nexport async function solveGrid(grid, setGrid) {\n  const newGrid = [...grid];\n  const emptySquare = findEmpty(grid);\n  if (emptySquare[0] === -1 && emptySquare[1] === -1) {\n    return true; //Grid is full\n  }\n  for (let i = 1; i < 10; i++) {\n    if (isValid(grid, emptySquare, i)) {\n      //see if num can fit\n      grid[emptySquare[0]][emptySquare[1]] = i;\n      setGrid(newGrid);\n      await sleep(window.solveSpeed);\n      if (await solveGrid(grid, setGrid)) {\n        //recursivly check new grid, if new grid is full then returns true SOlution Found\n        return true;\n      } else {\n        //try again with new number\n        grid[emptySquare[0]][emptySquare[1]] = 0;\n        setGrid(newGrid);\n        await sleep(window.solveSpeed);\n      }\n    }\n  }\n  return false;\n}\n\nfunction findEmpty(grid) {\n  for (let row = 0; row < 9; row++) {\n    for (let col = 0; col < 9; col++) {\n      if (grid[row][col] === 0) {\n        return [row, col];\n      }\n    }\n  }\n  return [-1, -1];\n}\n\nfunction isValid(grid, square, num) {\n  for (let i = 0; i < 9; i++) {\n    if (grid[square[0]][i] === num && i !== square[1]) {\n      return false;\n    }\n  }\n  for (let i = 0; i < 9; i++) {\n    if (grid[i][square[1]] === num && i !== square[0]) {\n      return false;\n    }\n  }\n\n  const boxRow = Math.floor(square[0] / 3);\n  const boxColumn = Math.floor(square[1] / 3);\n\n  for (let i = boxRow * 3; i < boxRow * 3 + 3; i++) {\n    for (let j = boxColumn * 3; j < boxColumn * 3 + 3; j++) {\n      if (grid[i][j] === num && i !== square[0] && j !== square[1]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction sleep(duration) {\n  if (duration === 0) {\n    return;\n  }\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve();\n    }, duration);\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}