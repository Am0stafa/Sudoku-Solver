{"ast":null,"code":"import _regeneratorRuntime from \"/Users/abdomostafa/Sudoku-Solver/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"/Users/abdomostafa/Sudoku-Solver/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"/Users/abdomostafa/Sudoku-Solver/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nexport function checkGrid(grid) {\n  for (var i = 0; i < 9; i++) {\n    var rowSet = new Set();\n    var colSet = new Set();\n    var boxSet = new Set();\n\n    for (var j = 0; j < 9; j++) {\n      var r = grid[i][j]; //current row cell checked\n\n      var c = grid[j][i]; //current col cell checked\n\n      var b = grid[3 * Math.floor(i / 3) + Math.floor(j / 3)][3 * (i % 3) + j % 3]; //current box cell checked\n\n      if (r === 0) {\n        return false;\n      } else if (rowSet.has(r)) {\n        return false;\n      } else {\n        rowSet.add(r);\n      }\n\n      if (c === 0) {\n        return false;\n      } else if (colSet.has(c)) {\n        return false;\n      } else {\n        colSet.add(c);\n      }\n\n      if (b === 0) {\n        return false;\n      } else if (boxSet.has(b)) {\n        return false;\n      } else {\n        boxSet.add(b);\n      }\n    }\n  }\n\n  return true;\n}\nexport function solveGrid(_x, _x2) {\n  return _solveGrid.apply(this, arguments);\n}\n\nfunction _solveGrid() {\n  _solveGrid = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(grid, setGrid) {\n    var newGrid, emptySquare, i;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            newGrid = _toConsumableArray(grid);\n            emptySquare = findEmpty(grid);\n\n            if (!(emptySquare[0] === -1 && emptySquare[1] === -1)) {\n              _context.next = 4;\n              break;\n            }\n\n            return _context.abrupt(\"return\", true);\n\n          case 4:\n            i = 1;\n\n          case 5:\n            if (!(i < 10)) {\n              _context.next = 24;\n              break;\n            }\n\n            if (!isValid(grid, emptySquare, i)) {\n              _context.next = 21;\n              break;\n            }\n\n            //see if num can fit\n            grid[emptySquare[0]][emptySquare[1]] = i;\n            setGrid(newGrid);\n            _context.next = 11;\n            return sleep(window.solveSpeed);\n\n          case 11:\n            _context.next = 13;\n            return solveGrid(grid, setGrid);\n\n          case 13:\n            if (!_context.sent) {\n              _context.next = 17;\n              break;\n            }\n\n            return _context.abrupt(\"return\", true);\n\n          case 17:\n            //try again with new number\n            grid[emptySquare[0]][emptySquare[1]] = 0;\n            setGrid(newGrid);\n            _context.next = 21;\n            return sleep(window.solveSpeed);\n\n          case 21:\n            i++;\n            _context.next = 5;\n            break;\n\n          case 24:\n            return _context.abrupt(\"return\", false);\n\n          case 25:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _solveGrid.apply(this, arguments);\n}\n\nfunction findEmpty(grid) {\n  for (var row = 0; row < 9; row++) {\n    for (var col = 0; col < 9; col++) {\n      if (grid[row][col] === 0) {\n        return [row, col];\n      }\n    }\n  }\n\n  return [-1, -1];\n}\n\nfunction isValid(grid, square, num) {\n  for (var i = 0; i < 9; i++) {\n    if (grid[square[0]][i] === num && i !== square[1]) {\n      return false;\n    }\n  }\n\n  for (var _i = 0; _i < 9; _i++) {\n    if (grid[_i][square[1]] === num && _i !== square[0]) {\n      return false;\n    }\n  }\n\n  var boxRow = Math.floor(square[0] / 3);\n  var boxColumn = Math.floor(square[1] / 3);\n\n  for (var _i2 = boxRow * 3; _i2 < boxRow * 3 + 3; _i2++) {\n    for (var j = boxColumn * 3; j < boxColumn * 3 + 3; j++) {\n      if (grid[_i2][j] === num && _i2 !== square[0] && j !== square[1]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction sleep(duration) {\n  if (duration === 0) {\n    return;\n  }\n\n  return new Promise(function (resolve) {\n    setTimeout(function () {\n      resolve();\n    }, duration);\n  });\n}","map":{"version":3,"sources":["/Users/abdomostafa/Sudoku-Solver/src/util.js"],"names":["checkGrid","grid","i","rowSet","Set","colSet","boxSet","j","r","c","b","Math","floor","has","add","solveGrid","setGrid","newGrid","emptySquare","findEmpty","isValid","sleep","window","solveSpeed","row","col","square","num","boxRow","boxColumn","duration","Promise","resolve","setTimeout"],"mappings":"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","sourcesContent":["export function checkGrid(grid) {\n  for (let i = 0; i < 9; i++) {\n    let rowSet = new Set();\n    let colSet = new Set();\n    let boxSet = new Set();\n\n    for (let j = 0; j < 9; j++) {\n      let r = grid[i][j]; //current row cell checked\n      let c = grid[j][i]; //current col cell checked\n      let b =\n        grid[3 * Math.floor(i / 3) + Math.floor(j / 3)][3 * (i % 3) + (j % 3)]; //current box cell checked\n\n      if (r === 0) {\n        return false;\n      } else if (rowSet.has(r)) {\n        return false;\n      } else {\n        rowSet.add(r);\n      }\n\n      if (c === 0) {\n        return false;\n      } else if (colSet.has(c)) {\n        return false;\n      } else {\n        colSet.add(c);\n      }\n\n      if (b === 0) {\n        return false;\n      } else if (boxSet.has(b)) {\n        return false;\n      } else {\n        boxSet.add(b);\n      }\n    }\n  }\n  return true;\n}\n\nexport async function solveGrid(grid, setGrid) {\n  const newGrid = [...grid];\n  const emptySquare = findEmpty(grid);\n  if (emptySquare[0] === -1 && emptySquare[1] === -1) {\n    return true; //Grid is full\n  }\n  for (let i = 1; i < 10; i++) {\n    if (isValid(grid, emptySquare, i)) {\n      //see if num can fit\n      grid[emptySquare[0]][emptySquare[1]] = i;\n      setGrid(newGrid);\n      await sleep(window.solveSpeed);\n      if (await solveGrid(grid, setGrid)) {\n        //recursivly check new grid, if new grid is full then returns true SOlution Found\n        return true;\n      } else {\n        //try again with new number\n        grid[emptySquare[0]][emptySquare[1]] = 0;\n        setGrid(newGrid);\n        await sleep(window.solveSpeed);\n      }\n    }\n  }\n  return false;\n}\n\nfunction findEmpty(grid) {\n  for (let row = 0; row < 9; row++) {\n    for (let col = 0; col < 9; col++) {\n      if (grid[row][col] === 0) {\n        return [row, col];\n      }\n    }\n  }\n  return [-1, -1];\n}\n\nfunction isValid(grid, square, num) {\n  for (let i = 0; i < 9; i++) {\n    if (grid[square[0]][i] === num && i !== square[1]) {\n      return false;\n    }\n  }\n  for (let i = 0; i < 9; i++) {\n    if (grid[i][square[1]] === num && i !== square[0]) {\n      return false;\n    }\n  }\n\n  const boxRow = Math.floor(square[0] / 3);\n  const boxColumn = Math.floor(square[1] / 3);\n\n  for (let i = boxRow * 3; i < boxRow * 3 + 3; i++) {\n    for (let j = boxColumn * 3; j < boxColumn * 3 + 3; j++) {\n      if (grid[i][j] === num && i !== square[0] && j !== square[1]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction sleep(duration) {\n  if (duration === 0) {\n    return;\n  }\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve();\n    }, duration);\n  });\n}\n"]},"metadata":{},"sourceType":"module"}